/*
 * File:   sensorsimulation.cpp
 * Author: Fang Yuan
 *
 */

#include <thread>
#include <opencv2/opencv.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <iostream>
#include <ctime>
#include <fstream>
#include "obstacle.h"

using namespace cv;
using namespace std;
using namespace Kalman;

// some variable initializations
Mat frame;
int quit = 0;
int finish = 0;
int pause = 0;
unsigned i = 1;
unsigned k = 0;
Mutex mimage, mpause;
obstacleEKF filter;

// define format of output video file
Size_<int> framesize(640, 360);
VideoWriter stream2("SimulatedEKF.avi", CV_FOURCC('A','P','4','1'), 10, framesize);

// function to input video like a real time video feed
void capture1();

// add sensor fusion information to each frame
int displayData(const Kalman::Vector& measure_depthmap, const Matrix& measure_ultrasonic);


int main() {
	// open file for reading, which is generated by the Matlab script <generation.m>
	selectKVectorContext(createKVectorContext(" ", "[ ", " ];", 4));
	selectKMatrixContext(createKMatrixContext(" ", " ;\n  ", "[ ", " ];", 4));

	ifstream dataInput;
	std::string tmpStr;

	dataInput.open("sensor_data.m",ifstream::in);

	if (dataInput.fail())
	{
		cout<<"Unable to open input file!"<<endl;
		return 0;
	}

	cout<<"Loading measures from file <sensor_data.m>."<<endl;

	// initialize the data holder
	const unsigned N = 500;
	Kalman::Vector F(N);
	Matrix measure_ultrasonic(21,N);
	Kalman::Vector measure_depthmap(N);

	//read the control vector.
	dataInput>>tmpStr;
	dataInput>>tmpStr;
	dataInput>>F;

	if (dataInput.fail())
	{
		cout<<"IO error!"<<endl;
		return 0;
	}

	//read the measurements of ultrasonic sensor.
	dataInput>>tmpStr;
	dataInput>>tmpStr;
	dataInput>>tmpStr;
	dataInput>>measure_ultrasonic;

	if (dataInput.fail())
	{
		cout<<"IO error!"<<endl;
		return 0;
	}

	//read the measurements of depth map. 
	dataInput>>tmpStr;
	dataInput>>tmpStr;
	dataInput>>tmpStr;
	dataInput>>measure_depthmap;

	if (dataInput.fail())
	{
		cout<<"IO error!"<<endl;
		return 0;
	}

	// initialize Kalman Filter
	static const double temp_P[] = {0.25, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.25};
	Matrix P(3,3,temp_P);
	Kalman::Vector x(3);
	x(1) = 34; //position
	x(2) = -9.5; //velocity
	x(3) = 1.5; //acceleration
	filter.init(x,P);

	// open the frame capture thread	
	thread t1(capture1);
	
	// wait for initialization of frame capture thread
	cout << "Waiting for stream to initialize" << endl;
	while (1){
		mimage.lock();
		if (frame.empty()==false){
			mimage.unlock();
			break;
		}
		mimage.unlock();
		this_thread::sleep_for(chrono::milliseconds(50));
	}
	cout << "Stream initialized\n";
	
	// add EKF data to each frame
	while (quit==0 && finish==0) {	
		displayData(measure_depthmap, measure_ultrasonic);	
	}

	t1.join();

	return 0;
}

// function to input video like a real time video feed
void capture1(){
	unsigned cnt = 1;
	VideoCapture stream1("TrafficVideo.mp4");	
	int type=16;
	double fps=25.0;
	Mat carview(360, 640, type);
	
	int64 t1,t0 = getTickCount();

	while(quit==0){
		mpause.lock();
		mpause.unlock();

		t1= getTickCount();

		if (fps*(t1-t0)/getTickFrequency()>1) {

			t0=getTickCount();
			
			if (cnt > stream1.get(CV_CAP_PROP_FRAME_COUNT))
			{
				finish = 1;			
				break;
			}

			stream1.read(carview);
			mimage.lock();
			carview.copyTo(frame);
			mimage.unlock();
			//cout << "...one frame is grabbed" << endl;
			cnt++;
		} 
		else {
			this_thread::sleep_for(chrono::milliseconds(1));
		}
	}

	stream1.release();
}

// add sensor fusion information to each frame
int displayData(const Kalman::Vector& measure_depthmap, const Matrix& measure_ultrasonic){
	// definitions for images
	Mat myimage;

	// aquire images
	mimage.lock();
	frame.copyTo(myimage);
	mimage.unlock();

	// definitions of data display positions
	Point_<int> pos1(40, 50);
	Point_<int> pos2(40, 70);
	Point_<int> pos3(40, 90);
	Point_<int> pos4(40, 110);
	Point_<int> pos5(40, 270);
	Point_<int> pos6(40, 290);
	Point_<int> pos7(40, 310);

	// initialize input variables
	Kalman::Vector u_(1,1.0);
	Kalman::Vector z_sensor(3);
	Kalman::Vector z_depthmap(1);

	z_depthmap(1) = measure_depthmap(i);
	z_sensor(1) = measure_ultrasonic(1,i);
	z_sensor(2) = measure_ultrasonic(2,i);
	z_sensor(3) = measure_ultrasonic(3,i);

	if (pause == 0)
		cout << "...sensor information is collected" << endl;

	// run sensor fusion algorithm
	if (pause == 0)
	{
		k = 0;
		while (!filter.dataFeasibility(z_sensor))
		{
			k++;
			if (k == 7)
			{
				filter.step(u_, z_depthmap);	
				break;
			}
			z_sensor(1) = measure_ultrasonic(1+(3*k),i);
			z_sensor(2) = measure_ultrasonic(2+(3*k),i);
			z_sensor(3) = measure_ultrasonic(3+(3*k),i);		
		}

		if (k <= 6)
		{
			filter.step(u_, z_sensor, z_depthmap);
		}
	}

	if (pause == 0)
		cout << "...moving object state (position, velocity, acceleration) is estimated" << endl;
	
	//add sensor fusion information to the frame
	putText(myimage, to_string(z_sensor(1)), pos1, FONT_HERSHEY_TRIPLEX, 0.5, Scalar(255, 255, 255));
	putText(myimage, to_string(z_sensor(2)), pos2, FONT_HERSHEY_TRIPLEX, 0.5, Scalar(255, 255, 255));
	putText(myimage, to_string(z_sensor(3)), pos3, FONT_HERSHEY_TRIPLEX, 0.5, Scalar(255, 255, 255));
	putText(myimage, to_string(z_depthmap(1)), pos4, FONT_HERSHEY_TRIPLEX, 0.5, Scalar(255, 255, 255));
	putText(myimage, to_string(filter.getX()(1)), pos5, FONT_HERSHEY_TRIPLEX, 0.5, Scalar(255, 255, 255));
	putText(myimage, to_string(filter.getX()(2)), pos6, FONT_HERSHEY_TRIPLEX, 0.5, Scalar(255, 255, 255));
	putText(myimage, to_string(filter.getX()(3)), pos7, FONT_HERSHEY_TRIPLEX, 0.5, Scalar(255, 255, 255));
	
	// show the frames
	imshow("simulation",myimage);
	int key = waitKey(70); 

	// save the frames
	stream2.write(myimage);

	if (pause == 0)
		cout << "...information is added to the frame" << endl;

	if ( key == 112) { // P for pause
		if (pause==0) {
			cout << "Pause" << flush;
 			mpause.trylock();
			pause = 1;
		}
		else {
			cout << "\r       \r" << flush;
			pause = 0;
 			mpause.unlock();
		}
	} 
	else if (key == 27 || key==113) // ESC & q for quit
		quit = 1;	
	
	if (pause == 0)
		i++;
}
